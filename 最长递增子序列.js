/**
 * 求最长递增子序列 (LIS)(Vue3)
 * @param {number[]} numbers
 * 分析: 9, 10, 1, 2, 7, 3, 10, 18
 *  - [9]  (最长递增子序列: 9)
 *      9 (最长递增子序列: 9) 长度是1
 *  - [9, 10] => 根据末尾元素判断, > 9, 拓展一行
 *      9  (第一个数字是 9) 长度是1
 *      9 10 (最长递增子序列: 9, 10) 长度是2
 *  - [9, 10, 1] => 1 < 10暂不处理, 第一行比较 < 9, 则替换第一行
 *      1  (第一个数字是 1) (取更小的更合适)这里长度是1
 *      9 10 (最长递增子序列: 9, 10) 这里长度是2
 *  - [9, 10, 1, 2] => 2 与每一行末尾比较, 是否能接上, 接上则下一行变成接上的结果 [1, 2]
 *      1  (第一个数字是 1) 长度是1
 *      1 2 (最长递增子序列: 1, 2) 长度是2
 *  - [9, 10, 1, 2, 7] => 7 与 2可以接上, 则下一行变成接上的结果 [1, 2, 7]
 *      1  (第一个数字是 1) 长度是1
 *      1 2 (最长递增子序列: 1, 2) 长度是2
 *      1 2 7  (第一个数字是 1, 2, 7) 长度是3
 *  - [9, 10, 1, 2, 7, 3] => 3 与 7 接不上, 和 [1, 2] 接上, 则下一行变成接上的结果 [1, 2, 3]
 *      1  (第一个数字是 1) 长度是1
 *      1 2 (最长递增子序列: 1, 2) 长度是2
 *      1 2 3 (最长递增子序列: 1, 2, 3) 长度是3
 *  - [9, 10, 1, 2, 7, 3, 10] => 10 与 3 接上, 则下一行变成接上的结果 [1, 2, 3, 10]
 *      1  (第一个数字是 1) 长度是1
 *      1 2 (最长递增子序列: 1, 2) 长度是2
 *      1 2 3 (最长递增子序列: 1, 2, 3) 长度是3
 *      1 2 3 10 (最长递增子序列: 1, 2, 3, 10) 长度是4
 *  - [9, 10, 1, 2, 7, 3, 10, 18] => 18 与 10 接上, 则下一行变成接上的结果 [1, 2, 3, 10, 18]
 *      1  (第一个数字是 1) 长度是1
 *      1 2 (最长递增子序列: 1, 2) 长度是2
 *      1 2 3 (最长递增子序列: 1, 2, 3) 长度是3
 *      1 2 3 10 (最长递增子序列: 1, 2, 3, 10) 长度是4
 *      1 2 3 10 18 (最长递增子序列: 1, 2, 3, 10, 18) 长度是5
 * 
 * 结果里面最后一行是最长递增子序列
 * return [1, 2, 3, 10, 18]
 */
function LIS(numbers) {
    if (numbers.length === 0) {
        return [];
    }
    // 构建二维数组, 上面分析的二维数组数据结构
    const results = [[numbers[0]]]; // 第一行是第一项
    for (let i = 1; i < numbers.length; i++) {
        const current = numbers[i];
        _update(current);
    }

    /**
     * 新的数字进来, 倒序循环二维数组, 最后一个数字比较是否可以接上
     *  - 接上, 则新开一行, 记录接上的结果
     *  - 比较上一行接上, 则替换下一行变成接上的结果
     * 
     *  如果后面出现了一个很小的, 不用考虑替换下一行后面的, 因为求最长, 如果后续能变成最长, 则自己回替换后面的结果
     */
    function _update(current) {
        for (let i = results.length - 1; i >= 0; i--) {
            const line = results[i];
            const tail = line[line.length - 1];
            if (current > tail) {
                results[i + 1] = [...line, current];
                return;
            }
        }
        results[0] = [current];
    }
    console.log(results);
    return results[results.length - 1];
}

console.log(LIS([9, 10, 1, 2, 7, 3, 10, 18]));
// expect: [1, 2, 3, 10, 18]
console.log(LIS([9, 10, 1, 2, 7, 3, 4, 1.1, 1.2, 1.3, 10, 18]));
// [ 1, 1.1, 1.2, 1.3, 10, 18 ]
console.log(LIS([9, 10, 1, 2, 7, 3, 4, 1.1, 1.2, 10, 18]));
// [ 1, 2, 3, 4, 10, 18 ]
console.log(LIS([9, 10, 1, 2, 7, 3, 4, 1.1, 1.2, 10, 18]));
