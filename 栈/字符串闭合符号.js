// 有效括号: 给定一个包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。 有效字符串需满足：
// 左括号必须用相同类型的右括号闭合。
// 左括号必须以正确的顺序闭合。


// 示例 1：
// 输入：s = "()"
// 输出：true

// 示例 2：
// 输入：s = "()[]{}"
// 输出：true

// 示例 3：
// 输入：s = "(]"
// 输出：false

// 示例 4：
// 输入：s = "([)]"
// 输出：false

// 示例 5：
// 输入：s = "{[]}"
// 输出：true

// 思路:
// 根据对称性，而栈（后入先出）入栈和出栈恰好是反着来，形成了鲜明的对称性
// 入栈：abc，出栈：cba
// 输入：s = "{[()]}"
// 第一步：读取ch = {，属于左括号，入栈，此时栈内有{
// 第二步：读取ch = [，属于左括号，入栈，此时栈内有{[
// 第三步：读取ch = (，属于左括号，入栈，此时栈内有{[(
// 第四步：读取ch = )，属于右括号，尝试读取栈顶元素(和)正好匹配，将(出栈，此时栈内还剩{[
// 第五步：读取ch = ]，属于右括号，尝试读取栈顶元素[和]正好匹配，将[出栈，此时栈内还剩{
// 第六步：读取ch = }，属于右括号，尝试读取栈顶元素{和}正好匹配，将{出栈，此时栈内还剩''
// 第七步：栈内只能''，s = "{[()]}"符合有效的括号定义，返回true


function isValid(s) {
    if (!s) {
        return true;
    }
    // ^在正则表达式中表示取反，即匹配除了括号以外的字符
    const sl = s.replace(/[^\(\)\{\}\[\]]/g, '');
    const map = {
        '(': ')',
        '{': '}',
        '[': ']',
    };
    const stack = [];
    for (let i = 0; i < sl.length; i++) {
        const val = sl[i];
        if (map[val]) {
            // 收集左括号
            stack.push(val);
        }
        else {
            // 右括号开始匹配
            // 1. 如果栈内没有左括号，直接false
            // 2. 有数据但是栈顶元素不是当前的右括号
            if (!stack.length || map[stack.pop()] !== val) {
                return false;
            }
        }
    }
    return !stack.length;
};
console.log(isValid('aa{bb[cc(dd)ee]ff}gg')); // true
console.log(isValid('()[]{}')); // true
console.log(isValid('([)]')); // false
console.log(isValid('([)')); // false
